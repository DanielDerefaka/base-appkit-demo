# 1) Summary

Build and ship a minimal, production‑ready **Base (chainId 8453)** dapp that integrates **Reown AppKit (WalletConnect)** for wallet connection, chain gating, and message signing. The goal is to produce a public, open‑source deployment that clearly qualifies as an **eligible WalletConnect‑on‑Base contribution**.

---

# 2) Goals & Success Metrics

**Primary Goal**

* A live dapp (public URL) where users can connect a wallet via **Reown AppKit**, auto/suggest switch to **Base**, view wallet info/balance, and sign a short “Builder Proof” message.

**Success Metrics (Week 1)**

* ✅ Public GitHub repo with permissive license (MIT).
* ✅ Deployed on Vercel (or equivalent) with working connect/sign on Base.
* ✅ Clear README mentioning **Base + Reown AppKit** and linking to live app.
* ✅ Commits and on‑chain interactions attributable to your GitHub/wallet.
* ✅ Optional: simple on‑chain write on Base (e.g., emit event), and verified contract.

**Nice‑to‑Have Metrics**

* Lighthouse Performance ≥ 85 for the main page.
* CI build/test pipeline green on each commit.
* Basic telemetry of connect/sign actions (privacy‑safe).

---

# 3) Scope

**In Scope (MVP v1)**

* Next.js (App Router) single‑page dapp.
* Integrate **Reown AppKit** + **Wagmi/Viem**.
* Network gating to **Base** (8453) only.
* Display wallet address, chain, and native balance.
* "**Sign Builder Proof**" action with signature shown in UI and (locally) verified.
* Responsive UI with a minimal, clean design.
* Public GitHub repository + hosted deployment.

**Out of Scope (for v1)**

* Complex contract interactions or backend services.
* Persistent user accounts, databases, or auth beyond wallet connection.
* Token swaps, bridging, or transfers.

**v1.1 (Follow‑ups)**

* Deploy & verify a tiny Base contract ("ProofOfBuildRegistry") that emits an event on write; optional UI button to call it.
* Basename lookup and display.
* Share‑to‑Farcaster button with prefilled copy linking repo/live site.

---

# 4) Users & Key Flows

**User Types**

* *Visitor/Reviewer*: wants to quickly verify there’s a real Base + WalletConnect integration.
* *Builder (you)*: needs a clean, testable artifact of the integration.

**Core Flows (MVP)**

1. **Open App** → Landing shows “Connect” button and Base logo/hint.
2. **Connect Wallet** → Reown AppKit modal opens and lists wallets.
3. **Chain Gating** → If not on Base, app prompts to switch (via wallet request). If the wallet refuses, show non‑blocking error and keep the Connect button visible.
4. **Show Account** → On connect + Base ready: show address (shortened), current chainId, and native ETH balance.
5. **Sign Proof** → User clicks **Sign Builder Proof**; app sends a static message like:
   `I’m a Base Builder using Reown AppKit. Address: <address>`
   App displays the resulting signature and locally verifies it with `verifyMessage` (no backend).

**Optional v1.1 Flow**
6. **On‑Chain Write** → Call a minimal contract method on Base (e.g., `logProof(address)`), show tx hash link to Basescan.

---

# 5) Functional Requirements

1. **Wallet Connect**

   * Must use **Reown AppKit** with a valid Project ID (from the Reown dashboard).
   * Provide the default AppKit button (`<appkit-button />`) to open the modal.
2. **Network Gating**

   * Default network: **Base (8453)**.
   * If user connects on a different chain, present an automatic/suggested chain switch.
3. **Account & Balance**

   * Display connected address (checksum + shortened) and chainId.
   * Fetch and display **Base ETH** balance using Viem/Wagmi.
4. **Sign Builder Proof**

   * Provide a button that triggers `personal_sign`/`signMessage`.
   * Surface the signature in UI; verify locally using Viem’s `verifyMessage` and render a "Verified" badge.
5. **Error Handling**

   * Clear, non‑technical messages for: no wallet, connection canceled, chain switch declined, RPC error.
6. **Telemetry (privacy‑safe)**

   * Capture basic client events: `connect_success`, `chain_switch_prompted`, `sign_success`, `sign_failed`. No PII; do **not** store addresses.

---

# 6) Non‑Functional Requirements

* **Performance**: First meaningful paint < 2.5s on a typical connection.
* **Reliability**: UI never hard‑crashes on failed wallet actions.
* **Security**: No private keys handled by the app; only standard provider requests. Content Security Policy for the domain.
* **Privacy**: No collection of emails or wallet addresses in telemetry.
* **Accessibility**: Keyboard navigation for main actions; aria labels for buttons.

---

# 7) Architecture & Tech

**Frontend**

* **Next.js (App Router)**, TypeScript, React 18.
* **Reown AppKit** + **@reown/appkit-adapter-wagmi**.
* **Wagmi** + **Viem** for provider, account, balance, sign/verify.
* CSS: minimal Tailwind or CSS modules; light/dark friendly.

**Configuration**

* `NEXT_PUBLIC_PROJECT_ID` – Reown Project ID.
* `NEXT_PUBLIC_BASE_RPC` – optional override (default Base RPC).

**No Backend (MVP)**

* All logic client‑side. Optional future API route for telemetry proxies if needed.

---

# 8) UI/UX

**Page Layout**

* Header: Title “Base + Reown AppKit Demo”. Small Base logo.
* Primary CTA: `<appkit-button />` (Connect).
* Info Card (post‑connect): address (with copy), chainId (expect 8453), balance.
* Action Card: **Sign Builder Proof** button; show signature + local verification result.
* Footer: Links to GitHub repo, live Basescan (if v1.1 contract present).

**States**

* Disconnected, Connecting, Connected (Wrong chain), Connected (Base), Signing, Signed.

---

# 9) Repo & Delivery

**Repo Checklist**

* MIT license.
* Descriptive README: purpose (Base + Reown AppKit), how to run, env vars, live URL, screenshots.
* Minimal CI: Node version pin, build succeeds on PRs.
* Prettier + ESLint; basic type‑checks.

**Branches**

* `main` → production.
* `dev` → working branch (optional).

**Commits**

* Conventional commits (e.g., `feat: add AppKit and Base gating`).

---

# 10) Testing & Acceptance Criteria

**Manual QA**

* On desktop and mobile browsers with injected wallets + WalletConnect‑compatible wallets.
* Connect succeeds via AppKit.
* If user is on the wrong chain, app prompts chain switch; after switch, balance loads.
* Sign message returns a signature; local verification passes.

**Acceptance Criteria (Go‑Live)**

* ✅ Live URL accessible publicly.
* ✅ Connect → Switch to Base (if needed) → Show address & balance.
* ✅ Sign Proof → signature displayed and verified.
* ✅ README clearly references **Base** and **Reown AppKit** and links to the live app.
* ✅ Source code public and builds cleanly.

---

# 11) Risk & Mitigation

* **Wallet incompatibility**: Rely on AppKit’s wallet list; document recommended wallets.
* **RPC rate limits**: Allow configurable RPC via env var; fall back to default.
* **Chain switch failure**: Gracefully notify and allow retry.
* **Telemetry concerns**: Keep analytics off by default; clearly document if enabled.

---

# 12) Timeline (suggested)

* **Day 1**: Repo init, AppKit wired, Base gating working.
* **Day 2**: UI polish, sign/verify, README, deploy to Vercel.
* **Day 3**: QA across wallets/browsers; finalize screenshots; announce + link on socials.
* **Day 4+ (v1.1)**: Optional contract deploy/verify; add Basescan link & write action.

---

# 13) Open Questions

* Do we want Basename lookup in v1 or v1.1?
* Do we add a minimal on‑chain write in v1 for stronger proof?
* Preferred analytics provider (if any) or skip entirely for MVP?

---

# 14) Appendix — "Builder Proof" Message Template

```
I’m a Base Builder using Reown AppKit.
Address: <0x…>
Date: <ISO8601>
Repo: <https://github.com/<user>/<repo>>
```

(Sign with the connected account; verify locally and display a green "Verified" label.)
